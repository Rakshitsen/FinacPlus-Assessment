// Scripted Pipeline for FinacPlus Assessment
// CI/CD: Git → Jenkins → Docker Hub → Kubernetes (kind cluster)
node {
    // ---------- 1. Initialize ----------
    properties([
        parameters([
            choice(name: 'TARGET_ENV', choices: ['dev','stage','prod'], description: 'Where to deploy/promote'),
            string(name: 'IMAGE_TAG', defaultValue: "${BUILD_NUMBER}", description: 'Image tag to deploy or promote'),
            booleanParam(name: 'ROLLBACK', defaultValue: false, description: 'If true, deploy IMAGE_TAG without building'),
            string(name: 'NAMESPACE_DEV', defaultValue: 'dev', description: 'Namespace for dev'),
            string(name: 'NAMESPACE_STAGE', defaultValue: 'stage', description: 'Namespace for stage'),
            string(name: 'NAMESPACE_PROD', defaultValue: 'prod', description: 'Namespace for prod')
        ])
    ])
    // Variables for image name, tags, and credentials
    def TAG = params.IMAGE_TAG
    def IMAGE_REPO = "rakshitsen/simple-app"
    def REGISTRY_CREDS = "Docker_cred"
    def KUBECONFIG_FILE = "KUBECONFIG_FILE"
    def DEPLOYMENT_FILE = "k8s/deployment.yml"
    def nsMap = ['dev': params.NAMESPACE_DEV, 'stage': params.NAMESPACE_STAGE, 'prod': params.NAMESPACE_PROD]
    def TARGET_NS = nsMap[params.TARGET_ENV]
    def TARGET_ENV = params.TARGET_ENV
    def ROLLBACK = params.ROLLBACK
    def VENV = "myenv"

    try {
        stage('Checkout Source') {
            // Pull latest code from main branch
            checkout scm
        }

        // ---------- 2. Build ----------
        stage('Build & Test') {
            sh '''
                echo "Installing dependencies and running quick tests..."
                python3 --version
                docker --version
            '''
        }


        stage('Setup Python Deps') {
            sh """
                set -e
                python3 -m venv $VENV
                . $VENV/bin/activate
                pip install --upgrade pip
                pip install -r requirements.txt -r requirements-dev.txt
            """
        }
        stage('Lint & Unit Tests') {
            withEnv(["PYTHONPATH=${env.WORKSPACE}"]) {
                sh """
                    set -e
                    . $VENV/bin/activate
                    ruff check .
                    python -m pytest -q --maxfail=1 --disable-warnings --junitxml=pytest-report.xml
                    rm -rf $VENV
                """
            }
            junit allowEmptyResults: true, testResults: 'pytest-report.xml'
            archiveArtifacts artifacts: 'pytest-report.xml', fingerprint: true, allowEmptyArchive: true
        }



        if (!ROLLBACK && TARGET_ENV == 'dev') {
            stage('Build Docker Image') {
                sh """
                    echo "Building Docker image ${IMAGE_REPO}:${TAG}"
                    docker build -t ${IMAGE_REPO}:${TAG} .
                    docker tag ${IMAGE_REPO}:${TAG} ${IMAGE_REPO}:latest
                """
            }
            stage('Security Scan') {
                sh """
                    echo "Scanning ${IMAGE_REPO}:${TAG} for vulnerabilities..."
                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\
                      aquasec/trivy:latest image --format table ${IMAGE_REPO}:${TAG} || true
                    
                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\
                      -v \$(pwd):/output \\
                      aquasec/trivy:latest image --format json --output /output/trivy-report-${BUILD_NUMBER}.json ${IMAGE_REPO}:${TAG} || true
                """
                archiveArtifacts artifacts: 'trivy-report-*.json', fingerprint: true, allowEmptyArchive: true
            }



            stage('Push Image to Registry') {
                withCredentials([usernamePassword(credentialsId: REGISTRY_CREDS, usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                    withEnv(["DOCKER_CONFIG=${env.WORKSPACE}/.docker-tmp","IMAGE_REPO=${IMAGE_REPO}", "TAG=${TAG}"]) {
                        sh """#!/usr/bin/env bash
                            set -euo pipefail
                            mkdir -p \$DOCKER_CONFIG
                            printf "%s" "\$PASS" | docker login -u "\$USER" --password-stdin
                            docker push "${IMAGE_REPO}:${TAG}"
                            docker tag "${IMAGE_REPO}:${TAG}" "${IMAGE_REPO}:latest"
                            docker push "${IMAGE_REPO}:latest"
                            docker logout || true
                            rm -rf \$DOCKER_CONFIG
                        """
                        sh """
                            cat > deploy-info-${BUILD_NUMBER}.txt <<EOF
                            \$(docker inspect --format='{{index .RepoDigests 0}}' "${IMAGE_REPO}:${TAG}")
                            EOF
                        """
                        archiveArtifacts artifacts: 'deploy-info-*.txt', fingerprint: true, followSymlinks: false
                    }
                }
            }
        } else {
            echo "Skipping build/push. Using existing image tag: ${TAG}"
        }


        stage('Deploy to Kubernetes') {
            withCredentials([file(credentialsId: KUBECONFIG_FILE, variable: 'KUBECONFIG_PATH')]) {
                sh """
                    echo "Target env: ${TARGET_ENV}, namespace: ${TARGET_NS}, tag: ${TAG}"

                    # Ensure namespace exists
                    kubectl --kubeconfig \$KUBECONFIG_PATH get ns ${TARGET_NS} >/dev/null 2>&1 || \\
                      kubectl --kubeconfig \$KUBECONFIG_PATH create ns ${TARGET_NS}

                    # First-time create vs update
                    if kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} get deploy simple-app >/dev/null 2>&1; then
                      echo "Deployment exists — updating image"
                      kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} \\
                        set image deploy/simple-app simple-app=${IMAGE_REPO}:${TAG}
                    else
                      echo "No deployment — creating resources"
                      kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} apply -f k8s/deployment.yml
                      kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} \\
                        set image deploy/simple-app simple-app=${IMAGE_REPO}:${TAG}
                    fi

                    echo "Waiting for rollout..."
                    kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} rollout status deploy/simple-app

                    echo "Running image in ${TARGET_NS}:"
                    kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} get deploy simple-app -o=jsonpath='{.spec.template.spec.containers[0].image}{"\\n"}'
                """
            }
        }


        // ---------- 6. Health Verification ----------
        stage('Verify Deployment') {
            withCredentials([file(credentialsId: KUBECONFIG_FILE, variable: 'KUBECONFIG_PATH')]) {
                sh """
                    echo "Checking /health endpoint..."
                    kubectl --kubeconfig \$KUBECONFIG_PATH port-forward svc/simple-app-service 7070:80 -n ${TARGET_NS} &
                    PF_PID=\$!
                    sleep 5
                    STATUS=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:7070/health)
                    kill \$PF_PID || true
                    if [ "\$STATUS" -ne 200 ]; then
                        echo "Health check failed (\$STATUS)"
                        exit 1
                    fi
                    echo "Healthy (HTTP 200)"
                """
            }
        }

        if (TARGET_ENV == 'dev' && !ROLLBACK) {
            stage('Approval for Stage Deployment') {
                timeout(time: 10, unit: 'MINUTES') {      
                    input message: "Promote ${IMAGE_REPO}:${TAG} to STAGE?", ok: "Deploy to Stage"
                }
            }

            echo "Promoting image ${IMAGE_REPO}:${TAG} to stage..."
            build job: env.JOB_NAME, parameters: [
                string(name: 'TARGET_ENV', value: 'stage'),
                string(name: 'IMAGE_TAG', value: TAG),
                booleanParam(name: 'ROLLBACK', value: false),
                string(name: 'NAMESPACE_DEV', value: params.NAMESPACE_DEV),
                string(name: 'NAMESPACE_STAGE', value: params.NAMESPACE_STAGE),
                string(name: 'NAMESPACE_PROD', value: params.NAMESPACE_PROD)
            ]
        }

        if (TARGET_ENV == 'stage' && !ROLLBACK) { 
            stage('Approval for Production Deployment') {
                timeout(time: 30, unit: 'MINUTES') {      
                    input message: "Promote ${IMAGE_REPO}:${TAG} to PRODUCTION?", ok: "Deploy to Production"
                }
            }

            echo "Promoting image ${IMAGE_REPO}:${TAG} to Production..."
            build job: env.JOB_NAME, parameters: [
                string(name: 'TARGET_ENV', value: 'prod'),
                string(name: 'IMAGE_TAG', value: TAG),
                booleanParam(name: 'ROLLBACK', value: true),
                string(name: 'NAMESPACE_DEV', value: params.NAMESPACE_DEV),
                string(name: 'NAMESPACE_STAGE', value: params.NAMESPACE_STAGE),
                string(name: 'NAMESPACE_PROD', value: params.NAMESPACE_PROD)
            ]
        }
        // ---------- 7. Cleanup ----------
        stage('Post-Build Cleanup') {
            sh "docker rmi ${IMAGE_REPO}:${TAG} || true"
            cleanWs()
        }
    } // CLOSING BRACE for the 'try' block
    finally {
        // ---------- Notify & Audit (always runs) ----------
        // Derive status and a few useful facts
        def STATUS = currentBuild.currentResult ?: 'SUCCESS'
        def SUMMARY = """
----------------------------------------
Deployment Summary
Env:        ${TARGET_ENV}
Namespace:  ${TARGET_NS}
Image:      ${IMAGE_REPO}:${TAG}
Build #:    ${BUILD_NUMBER}
Status:     ${STATUS}
----------------------------------------
"""

        echo SUMMARY

        // Optional: fetch running image in cluster for proof (ignore errors)
        withCredentials([file(credentialsId: KUBECONFIG_FILE, variable: 'KUBECONFIG_PATH')]) {
            sh """
                echo "Cluster image in ${TARGET_NS}:"
                kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} \\
                  get deploy simple-app -o=jsonpath='{.spec.template.spec.containers[0].image}{"\\n"}' || true
            """
        }


    }
} // end of node