// ======================================================================
// Scripted Pipeline for FinacPlus Assessment
// CI/CD: Git → Jenkins → Docker Hub → Kubernetes (kind cluster)
// ======================================================================

node {

    // ---------- 1. Initialize ----------
    properties([
        parameters([
            choice(name: 'TARGET_ENV', choices: ['dev', 'stage', 'prod'], description: 'Where to deploy/promote'),
            string(name: 'IMAGE_TAG', defaultValue: "${BUILD_NUMBER}", description: 'Image tag to deploy or promote'),
            string(name: 'IMAGE_DIGEST', defaultValue: '', description: 'Immutable image digest for promotion'),
            booleanParam(name: 'ROLLBACK', defaultValue: false, description: 'If true, deploy IMAGE_TAG without building'),
            string(name: 'NAMESPACE_DEV', defaultValue: 'dev', description: 'Namespace for dev'),
            string(name: 'NAMESPACE_STAGE', defaultValue: 'stage', description: 'Namespace for stage'),
            string(name: 'NAMESPACE_PROD', defaultValue: 'prod', description: 'Namespace for prod')
        ])
    ])

    // ---------- Variables ----------
    def TAG = params.IMAGE_TAG
    def IMAGE_REPO = "rakshitsen/simple-app"
    def REGISTRY_CREDS = "Docker_cred"
    def KUBECONFIG_FILE = "KUBECONFIG_FILE"
    def DEPLOYMENT_FILE = "k8s/deployment.yml"
    def nsMap = ['dev': params.NAMESPACE_DEV, 'stage': params.NAMESPACE_STAGE, 'prod': params.NAMESPACE_PROD]
    def TARGET_NS = nsMap[params.TARGET_ENV]
    def TARGET_ENV = params.TARGET_ENV
    def ROLLBACK = params.ROLLBACK
    def VENV = "myenv"
    def currentStage = 'Initialization'

    try {

        // ---------- 2. Checkout Source ----------
        // stage('Checkout Source') {
        //     currentStage = 'Checkout Source'
        //     checkout scm
        // }
        if (TARGET_ENV == 'dev' && !ROLLBACK) { 

        // ---------- 3. Env  Check ----------
        stage('Env Check') {
            currentStage = 'Env Check'
            sh '''
                echo "Installing dependencies and running quick tests..."
                python3 --version
                docker --version
            '''
        }

        // ---------- 4. Python Env Setup----------
        stage('Python Env Setup') {
            currentStage = 'Python Env Setup'
            sh """
                set -e
                python3 -m venv $VENV
                . $VENV/bin/activate
                pip install --upgrade pip
                pip install -r requirements.txt -r requirements-dev.txt
            """
        }

        // ---------- 5. Lint & Unit Tests ----------
        stage('Lint & Unit Tests') {
            currentStage = 'Lint & Unit Tests'
            withEnv(["PYTHONPATH=${env.WORKSPACE}"]) {
                sh """
                    set -e
                    . $VENV/bin/activate
                    ruff check .
                    python -m pytest -q --maxfail=1 --disable-warnings --junitxml=pytest-report.xml
                    rm -rf $VENV
                """
            }
            junit allowEmptyResults: true, testResults: 'pytest-report.xml'
            archiveArtifacts artifacts: 'pytest-report.xml', fingerprint: true, allowEmptyArchive: true
        }
        }

        // ---------- 6. Docker Build / Push ----------
        if (!ROLLBACK && TARGET_ENV == 'dev') {

            stage('Build Docker Image') {
                currentStage = 'Build Docker Image'
                sh """
                    echo "Building Docker image ${IMAGE_REPO}:${TAG}"
                    docker build -t ${IMAGE_REPO}:${TAG} .
                    docker tag ${IMAGE_REPO}:${TAG} ${IMAGE_REPO}:latest
                """
            }

            stage('Security Scan') {
                currentStage = 'Security Scan'
                sh """
                    echo "Scanning ${IMAGE_REPO}:${TAG} for vulnerabilities..."
                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                      aquasec/trivy:latest image --format table ${IMAGE_REPO}:${TAG} || true
                    
                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                      -v \$(pwd):/output \
                      aquasec/trivy:latest image --format json --output /output/trivy-report-${BUILD_NUMBER}.json ${IMAGE_REPO}:${TAG} || true
                """
                archiveArtifacts artifacts: 'trivy-report-*.json', fingerprint: true, allowEmptyArchive: true
            }

            stage('Push Image to Registry') {
                currentStage = 'Push Image to Registry'
                withCredentials([usernamePassword(credentialsId: REGISTRY_CREDS, usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                    withEnv(["DOCKER_CONFIG=${env.WORKSPACE}/.docker-tmp", "IMAGE_REPO=${IMAGE_REPO}", "TAG=${TAG}"]) {
                        sh """#!/usr/bin/env bash
                            set -euo pipefail
                            mkdir -p \$DOCKER_CONFIG
                            printf "%s" "\$PASS" | docker login -u "\$USER" --password-stdin
                            docker push "${IMAGE_REPO}:${TAG}"
                            docker tag "${IMAGE_REPO}:${TAG}" "${IMAGE_REPO}:latest"
                            docker push "${IMAGE_REPO}:latest"
                            docker logout || true
                            rm -rf \$DOCKER_CONFIG
                        """

                        // Capture digest into file
                        sh """
                            DIGEST=\$(docker inspect --format='{{index .RepoDigests 0}}' ${IMAGE_REPO}:${TAG})
                            echo "IMAGE_DIGEST=\$DIGEST" > image-digest.env
                        """
                        archiveArtifacts artifacts: 'image-digest.env', fingerprint: true
                    }
                }

                script {
                    def digestFile = readFile('image-digest.env').trim()
                    env.IMAGE_DIGEST = digestFile.split('=')[1]
                    echo "Captured image digest: ${env.IMAGE_DIGEST}"
                }
            }

        } else {
            echo "Skipping build/push. Using existing image tag: ${TAG}"
        }

        // ---------- 7. Deploy to Kubernetes ----------
        stage('Deploy to Kubernetes') {
            currentStage = 'Deploy to Kubernetes'
            withCredentials([file(credentialsId: KUBECONFIG_FILE, variable: 'KUBECONFIG_PATH')]) {
                def imageToDeploy = env.IMAGE_DIGEST ?: "${IMAGE_REPO}:${TAG}"
                sh """
                    echo "Deploying image: ${imageToDeploy}"
                    echo "Target env: ${TARGET_ENV}, namespace: ${TARGET_NS}, tag: ${TAG}"

                    kubectl --kubeconfig \$KUBECONFIG_PATH get ns ${TARGET_NS} >/dev/null 2>&1 || \
                      kubectl --kubeconfig \$KUBECONFIG_PATH create ns ${TARGET_NS}

                    if kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} get deploy simple-app >/dev/null 2>&1; then
                        echo "Deployment exists — updating image"
                        kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} \
                            set image deploy/simple-app simple-app=${imageToDeploy}
                    else
                        echo "No deployment — creating resources"
                        kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} apply -f k8s/deployment.yml
                        kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} \
                            set image deploy/simple-app simple-app=${imageToDeploy}
                    fi

                    echo "Waiting for rollout..."
                    kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} rollout status deploy/simple-app

                    echo "Running image in ${TARGET_NS}:"
                    kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} get deploy simple-app \
                        -o=jsonpath='{.spec.template.spec.containers[0].image}{"\\n"}'
                """
            }
        }

        // ---------- 8. Verify Deployment ----------
        stage('Verify Deployment') {
            currentStage = 'Verify Deployment'
            withCredentials([file(credentialsId: KUBECONFIG_FILE, variable: 'KUBECONFIG_PATH')]) {
                sh """
                    echo "Checking /health endpoint..."
                    kubectl --kubeconfig \$KUBECONFIG_PATH port-forward svc/simple-app-service 7070:80 -n ${TARGET_NS} &
                    PF_PID=\$!
                    sleep 5
                    STATUS=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:7070/health)
                    kill \$PF_PID || true
                    if [ "\$STATUS" -ne 200 ]; then
                        echo "Health check failed (\$STATUS)"
                        exit 1
                    fi
                    echo "Healthy (HTTP 200)"
                """
            }
        }

        // ---------- 9. Approval Gates ----------
        if (TARGET_ENV == 'dev' && !ROLLBACK) {
            stage('Approval for Stage Deployment') {
                currentStage = 'Approval for Stage Deployment'
                timeout(time: 10, unit: 'MINUTES') {
                    input message: "Promote ${IMAGE_REPO}:${TAG} to STAGE?", ok: "Deploy to Stage"
                }
            }

            echo "Promoting image ${IMAGE_REPO}:${TAG} to stage..."
            build job: env.JOB_NAME, parameters: [
                string(name: 'TARGET_ENV', value: 'stage'),
                string(name: 'IMAGE_TAG', value: TAG),
                string(name: 'IMAGE_DIGEST', value: env.IMAGE_DIGEST),
                booleanParam(name: 'ROLLBACK', value: false),
                string(name: 'NAMESPACE_DEV', value: params.NAMESPACE_DEV),
                string(name: 'NAMESPACE_STAGE', value: params.NAMESPACE_STAGE),
                string(name: 'NAMESPACE_PROD', value: params.NAMESPACE_PROD)
            ]
        }

        if (TARGET_ENV == 'stage' && !ROLLBACK) {
            stage('Approval for Production Deployment') {
                currentStage = 'Approval for Production Deployment'
                timeout(time: 30, unit: 'MINUTES') {
                    input message: "Promote ${IMAGE_REPO}:${TAG} to PRODUCTION?", ok: "Deploy to Production"
                }
            }

            echo "Promoting image ${IMAGE_REPO}:${TAG} to Production..."
            build job: env.JOB_NAME, parameters: [
                string(name: 'TARGET_ENV', value: 'prod'),
                string(name: 'IMAGE_TAG', value: TAG),
                string(name: 'IMAGE_DIGEST', value: env.IMAGE_DIGEST),
                booleanParam(name: 'ROLLBACK', value: true),
                string(name: 'NAMESPACE_DEV', value: params.NAMESPACE_DEV),
                string(name: 'NAMESPACE_STAGE', value: params.NAMESPACE_STAGE),
                string(name: 'NAMESPACE_PROD', value: params.NAMESPACE_PROD)
            ]
        }

        // ---------- 10. Cleanup ----------
        stage('Post-Build Cleanup') {
            currentStage = 'Post-Build Cleanup'
            sh "docker rmi ${IMAGE_REPO}:${TAG} || true"
            cleanWs()
        }

    } // try

    catch (Exception e) {
        currentBuild.result = 'FAILURE'
        echo """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BUILD FAILED
Stage: ${currentStage}
Error: ${e.message}
Build: #${BUILD_NUMBER}
Console: ${env.BUILD_URL}console
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
    }

    finally {
        // ---------- 11. Audit & Summary ----------
        def STATUS = currentBuild.currentResult ?: 'SUCCESS'
        def SUMMARY = """
----------------------------------------
Deployment Summary
Env:        ${TARGET_ENV}
Namespace:  ${TARGET_NS}
Image Tag:  ${IMAGE_REPO}:${TAG}
Digest:     ${env.IMAGE_DIGEST ?: 'N/A'}
Build #:    ${BUILD_NUMBER}
Status:     ${STATUS}
----------------------------------------
"""
        echo SUMMARY

        withCredentials([file(credentialsId: KUBECONFIG_FILE, variable: 'KUBECONFIG_PATH')]) {
            sh """
                echo "Cluster image running in ${TARGET_NS}:"
                kubectl --kubeconfig \$KUBECONFIG_PATH -n ${TARGET_NS} \
                  get deploy simple-app -o=jsonpath='{.spec.template.spec.containers[0].image}{"\\n"}' || true
            """
        }
    }

} // end node
